{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "def merge(input_list):\n",
    "    result=[]\n",
    "    for i, elem in enumerate(input_list):\n",
    "        if i%2 is 1:\n",
    "            s1=set()\n",
    "            for ele in elem:\n",
    "                s1.add(ele)\n",
    "            for ele in input_list[i-1]:\n",
    "                s1.add(ele)\n",
    "            li = list(s1.copy())\n",
    "            result.append(li)\n",
    "    return result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "def clustering(input_list):\n",
    "    result = []\n",
    "    poslist = []\n",
    "    zero_count = 0\n",
    "    count = 0\n",
    "    pos = 0\n",
    "    flag = False\n",
    "    \n",
    "    for i, elem in enumerate(input_list):\n",
    "        if elem is not 0:\n",
    "            flag = True\n",
    "            count +=1\n",
    "        \n",
    "        if elem is 0 and flag is True:\n",
    "            zero_count += 1\n",
    "            count += 1\n",
    "            \n",
    "        if zero_count is 3:\n",
    "            pos = i\n",
    "            result.append(pos - 2 - (count-2)//2)\n",
    "            poslist.append(pos-2-count)\n",
    "            zero_count =0\n",
    "            count = 0\n",
    "            flag = False\n",
    "    return (result ,poslist)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "def decisionRL(avgPoint, standardPoint):\n",
    "    if avg < standardPoint :\n",
    "        return \"RBBB\"\n",
    "    else :\n",
    "        return \"LBBB\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def kijunjum(input_list,x_pos):\n",
    "    temp = x_pos\n",
    "    flag = False\n",
    "    while(temp > 0):\n",
    "        if len(input_list[temp]) < 5 :\n",
    "            flag = True\n",
    "            temp = temp - 1 \n",
    "            if len(input_list[temp]) < 5 :\n",
    "                if len(input_list[temp]) is not 0:\n",
    "                    return (temp,input_list[temp][0])\n",
    "                else:\n",
    "                    return (temp,250)\n",
    "        else :\n",
    "            temp = temp -1\n",
    "    \n",
    "    return (x_pos,250)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 LBBB\n",
      "2 RBBB\n",
      "3 LBBB\n",
      "4 RBBB\n",
      "5 LBBB\n",
      "6 RBBB\n",
      "7 LBBB\n",
      "8 LBBB\n",
      "9 LBBB\n",
      "10 LBBB\n",
      "11 RBBB\n",
      "12 LBBB\n",
      "13 LBBB\n",
      "14 LBBB\n",
      "15 LBBB\n"
     ]
    }
   ],
   "source": [
    "#최대로 벌어진 마디가 몇번째 마디인지 (거리list , 제일벌어진마디 몇번째)\n",
    "def choichoi(index_list,list):\n",
    "    import numpy as np\n",
    "    index_chai_list = []\n",
    "    min_list = []\n",
    "    max_list = []\n",
    "    minmaxcha = []\n",
    "    for elem in index_list:\n",
    "        if elem-10<0 or elem+10>len(list):\n",
    "            index_chai_list.append(0)\n",
    "            pass\n",
    "        else:\n",
    "            narray=np.array(list[elem-5:elem+5])\n",
    "            min_idx = np.argmin(narray)\n",
    "            max_idx = np.argmax(narray)\n",
    "            index_chai_list.append(abs(min_idx-max_idx))\n",
    "            min_list.append(narray[min_idx])\n",
    "            max_list.append(narray[max_idx])\n",
    "\n",
    "    idx = np.argmax(np.array(index_chai_list))\n",
    "    #print(\"idxc:\",index_chai_list,\"idx:\",idx)\n",
    "    return (index_chai_list,idx)\n",
    "\n",
    "from PIL import Image\n",
    "import pdb\n",
    "import numpy as np\n",
    "import cv2\n",
    "import matplotlib.pyplot as plt\n",
    "yes = 0\n",
    "no = 0\n",
    "\n",
    "file_location = 'C:\\\\Users\\\\wnddk\\\\Desktop\\\\Search-PVC-Location-master\\\\patient\\\\LBBB\\\\'\n",
    "for _i in range(1,16):\n",
    "    img = cv2.imread(file_location+str(_i)+'.jpg')\n",
    "    im = Image.open(file_location+str(_i)+'.jpg')\n",
    "\n",
    "    subimg = img[70:570, 128:780]\n",
    "    b, g, r = cv2.split(subimg)\n",
    "\n",
    "\n",
    "#cv2.imwrite('1.jpg',b)\n",
    "#cv2.imshow('cutting' , subimg)\n",
    "\n",
    "\n",
    "\n",
    "    height, width, channel = subimg.shape\n",
    "#print(height, width)\n",
    " \n",
    "    pix = np.array(b)\n",
    "\n",
    "    _list=[]\n",
    "    testlist=[]\n",
    "##리스트가 아닌 2차원배열에 저장하는게 훨씬 좋을듯\n",
    "\n",
    "\n",
    "#(y,x) 형태 데이터를 (x,y)로 바꿈\n",
    "#height = 500 width = 652\n",
    "    for x in range(width):\n",
    "        temp = []\n",
    "        for y in range(height):\n",
    "            if pix[y][x] < 200:\n",
    "                temp.append(y)            \n",
    "        _list.append(temp)\n",
    "        testlist.append(temp)\n",
    "\n",
    "    \n",
    "#list는 x좌표 0부터 시작하고 해당하는 x좌표에 따른 y좌표 : ex) list [ [110,111,112]. [113.114,115]] \n",
    "#print(list)    \n",
    "\n",
    "\n",
    "#count_list :: x좌표에 그려진 y좌표의 픽셀 개수를 차례로 저장함\n",
    "    count_list = []\n",
    "    for x in range(width):\n",
    "        count_list.append(len(_list[x]))\n",
    "    \n",
    "#print(count_list)    \n",
    "\n",
    "#cv2.imshow('blue channel' , b)\n",
    "\n",
    "\n",
    "##기준점 픽스 시키기\n",
    "##픽셀값이 5이하이면 이걸 중앙으로 옮겨\n",
    "##fixed_list는 y좌표 옮긴 값\n",
    "\n",
    "    fixed_list = []\n",
    "    distance = 0\n",
    "    temp = []\n",
    "\n",
    "# ##############테스트용\n",
    "# a = [0 for i in range (width)]\n",
    "\n",
    "# for x in range(width - 2):\n",
    "#     if count_list[x] <= 3 and count_list[x+1] <=3 and count_list[x+2] <= 3: #x좌표의 y값들이 5개가 안되면 (일직선부분)\n",
    "        \n",
    "#         a[x] = distance\n",
    "#         if list[x] and list[x][0] < 270 and list[x][0] > 230: \n",
    "#             distance = abs(list[x][0] - 250) #중간값까지의 거리\n",
    "#             if list[x][0] < 250 : #그래프가 중간보다 위쪽이면\n",
    "#                 distance = distance    \n",
    "#             else:\n",
    "#                 distance = -distance;\n",
    "            \n",
    "#             for y in range(len(list[x])):\n",
    "#                 temp.append(list[x][y] + distance) #중간으로 위치조정하고\n",
    "            \n",
    "#             print(temp)\n",
    "#             fixed_list.append(temp)\n",
    "#             temp = []\n",
    "        \n",
    "#             for y in range(len(list[x+1])): #다음꺼 미리 위치조정 \n",
    "#                 list[x+1][y] = list[x+1][y] + distance;\n",
    "\n",
    "#         else :\n",
    "#             fixed_list.append([250])\n",
    "#     else: #x좌표의 y값들이 5개가 넘으면 (심장박동하는부분)\n",
    "        \n",
    "#         for y in range(len(list[x])):\n",
    "#             temp.append(list[x][y]) \n",
    "\n",
    "#         print(temp)\n",
    "#         fixed_list.append(temp)\n",
    "#         temp = []\n",
    "        \n",
    "#         for y in range(len(list[x+1])): #다음꺼 미리 위치조정 \n",
    "#              list[x+1][y] = list[x+1][y] + distance;\n",
    "\n",
    "# ####################################3\n",
    "#print(fixed_list[0])\n",
    "\n",
    "#print(len(list[46]))\n",
    "#print(len(list[49] + list[48] + list[47]))\n",
    "#out = open('output.txt' , 'w')\n",
    "#print(list, file=out)\n",
    "\n",
    "##y값의 길이가 비슷한것 끼리 사이의 거리를 구함 +-10%\n",
    "##세 픽셀의 값이 일정 (100개) 수준이 넘을때 마디\n",
    "##세 x픽셀의 y개수의 합이 +-10% 이상이면 다른 마디임 \n",
    "\n",
    "\n",
    "    test = np.zeros((height, width, 3),np.uint8)\n",
    "    test_h = test.shape[0]\n",
    "    test_w = test.shape[1]\n",
    "    test_bpp = test.shape[2]\n",
    "\n",
    "\n",
    "\n",
    "#fixed_counter_list : x좌표에 따른 y좌표가 20개 이하이면 0으로 바꿔버림\n",
    "    result=merge(merge(_list))\n",
    "    for x in range(len(result)):\n",
    "        for y in range(len(result[x])):\n",
    "            test = cv2.line(test,(x,result[x][y]),(x,result[x][y]),(255,255,255),1)\n",
    "    fixed_counter_list=[]\n",
    "    for i, elem in enumerate(count_list):\n",
    "        if elem<20:\n",
    "            fixed_counter_list.append(0)\n",
    "        else:\n",
    "            fixed_counter_list.append(elem)\n",
    "#print(fixed_counter_list)\n",
    "#cv2.imshow(\"test\", test)\n",
    "#print(result)\n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "#clustered : 마디의 x값의 좌표 list \n",
    "#idx : 최대로 벌어진 마디의 index 번호\n",
    "#idx2 : 최대로 벌어진 마디의 x좌표\n",
    "#idx3 : 기준점 x좌표\n",
    "\n",
    "    clustered = clustering(fixed_counter_list)[0]\n",
    "    standardPoint = clustering(fixed_counter_list)[1]\n",
    "    #print(clustered)\n",
    "\n",
    "    idx = choichoi(clustered,_list)[1]\n",
    "    idx2 = clustered[idx]\n",
    "    idx3 = standardPoint[idx] - 2\n",
    "    #print(idx,idx_2)\n",
    "    #clustered_list : 마디 양옆으로 5픽셀 범위내의 y값의\n",
    "    \n",
    "    \n",
    "    #print(choichoi(clustered,_list)[0])\n",
    "    #print(fixed_counter_list)\n",
    "    #print(clustered)\n",
    "    #print(idx2)\n",
    "\n",
    "    \n",
    "    clustered_list = _list[idx2-5:idx2+5]\n",
    "    \n",
    "    #print(idx2)\n",
    "    #print(idx3)\n",
    "    \n",
    "    #s1 : clustered_list의 y값들을 합친 집합\n",
    "    #avg : s1의 중간값 -> \n",
    "    s1 = set()\n",
    "    for i in clustered_list:\n",
    "        for j in i:\n",
    "            s1.add(j)\n",
    "    avg = (max(s1)+min(s1))//2\n",
    "    \n",
    "    #print(_list[idx3])\n",
    "    stdpt = kijunjum(_list,idx3)\n",
    "  \n",
    "\n",
    "    \n",
    "    print(str(_i) + ' ' + decisionRL(avg,stdpt[1]))\n",
    "\n",
    "    #빨간색이 마디의 x좌표\n",
    "    cv2.circle(subimg, (idx2,250),2,(0,0,255), 1)\n",
    "    #초록색이 중간값\n",
    "    cv2.circle(subimg, (idx2,avg),2,(0,255,0), 1)\n",
    "    #파란색이 기준점으로 잡은 위치\n",
    "    cv2.circle(subimg, (stdpt[0],stdpt[1]),2,(255,0,0), 1)\n",
    "    \n",
    "    #cv2.imshow(\"test\", subimg)\n",
    "    cv2.imwrite(str(_i) + '.jpg',subimg)\n",
    "    \n",
    "    cv2.waitKey(0)\n",
    "    cv2.destroyAllWindows()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
